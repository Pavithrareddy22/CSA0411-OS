/* file_syscalls.c
   Demonstrates: open, read, write, close, lseek, fcntl, stat, opendir, readdir
   Compile: gcc file_syscalls.c -o file_syscalls
*/
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string.h>
#include <errno.h>

int main(int argc, char *argv[]){
    if(argc < 3){
        fprintf(stderr,"Usage: %s <file-to-read> <directory-to-list>\n", argv[0]);
        return 1;
    }

    const char *fname = argv[1];
    int fd = open(fname, O_RDONLY);
    if(fd < 0){ perror("open"); return 1; }

    // fcntl example: get flags
    int flags = fcntl(fd, F_GETFL);
    if(flags == -1) perror("fcntl F_GETFL"); else printf("open flags = %d\n", flags);

    // stat
    struct stat st;
    if(stat(fname, &st) == 0){
        printf("File %s: size=%lld bytes, mode=%o\n", fname, (long long)st.st_size, st.st_mode & 0777);
    } else perror("stat");

    // read first 512 bytes
    char buf[513]; ssize_t r = read(fd, buf, 512);
    if(r < 0) perror("read"); else {
        buf[r]=0;
        printf("--- first %zd bytes ---\n%s\n-----------------------\n", r, buf);
    }

    // lseek: go to end and tell position
    off_t off = lseek(fd, 0, SEEK_END);
    if(off == (off_t)-1) perror("lseek"); else printf("File size by lseek = %lld\n", (long long)off);

    close(fd);

    // list directory using opendir/readdir
    DIR *d = opendir(argv[2]);
    if(!d){ perror("opendir"); return 1; }
    printf("Contents of directory %s:\n", argv[2]);
    struct dirent *de;
    while((de = readdir(d)) != NULL){
        printf("  %s\n", de->d_name);
    }
    closedir(d);
    return 0;
}

/* file_ops.c
   Copy, move (rename), delete using syscalls.
   Compile: gcc file_ops.c -o file_ops
   Usage: ./file_ops copy src dst
          ./file_ops move src dst
          ./file_ops delete target
*/
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>

#define BUF_SIZE 4096

int copy_file(const char *src, const char *dst){
    int in = open(src, O_RDONLY);
    if(in < 0){ perror("open src"); return -1; }
    int out = open(dst, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(out < 0){ perror("open dst"); close(in); return -1; }
    char buf[BUF_SIZE];
    ssize_t r;
    while((r = read(in, buf, BUF_SIZE)) > 0) {
        ssize_t w = write(out, buf, r);
        if(w != r){ perror("write"); close(in); close(out); return -1; }
    }
    if(r < 0) perror("read");
    close(in); close(out);
    return r<0?-1:0;
}

int main(int argc,char *argv[]){
    if(argc < 3){ fprintf(stderr,"Usage: %s <copy|move|delete> args...\n", argv[0]); return 1; }
    if(strcmp(argv[1],"copy")==0){
        if(argc!=4){ fprintf(stderr,"copy requires src dst\n"); return 1; }
        return copy_file(argv[2], argv[3])==0?0:1;
    } else if(strcmp(argv[1],"move")==0){
        if(argc!=4){ fprintf(stderr,"move requires src dst\n"); return 1; }
        if(rename(argv[2], argv[3])==0) { printf("Moved.\n"); return 0; }
        perror("rename"); return 1;
    } else if(strcmp(argv[1],"delete")==0){
        if(argc!=3){ fprintf(stderr,"delete requires target\n"); return 1; }
        if(unlink(argv[2])==0){ printf("Deleted.\n"); return 0; }
        perror("unlink"); return 1;
    } else { fprintf(stderr,"Unknown op\n"); return 1; }
}
